
// Import required libraries
#include <ESP_SSD1306.h>    // Modification of Adafruit_SSD1306 for ESP8266 compatibility
#include <Adafruit_GFX.h>   // Needs a little change in original Adafruit library (See README.txt file)
#include <SPI.h>            // For SPI comm (needed for not getting compile error)
#include <Wire.h>           // For I2C comm, but needed for not getting compile error
#include <ESP8266WiFi.h>    // For Wifi support
#include <BlynkSimpleEsp8266.h>
#include <OneWire.h>
#include "DHT.h"

#define DHTPIN 2
#define DHTTYPE DHT22

DHT dht(DHTPIN, DHTTYPE);

// Pin definitions
#define OLED_RESET  16            // Pin 15 -RESET digital signal
ESP_SSD1306 display(OLED_RESET);  // FOR I2C
const char* ssid = "RaffaelliG";
const char* password = "Cefalonia@740";
WiFiServer server(80);
int ledPin = 15; // GPIO15

String ipStatus = "";
String switchStatus = "";
String signalStrengths = "Signal: - ";

int delaySignalStrengths = 5000;
int delaySignalStrengthsCounter = delaySignalStrengths;

int valuePin = LOW;
char auth[] = "65909a05db6d4504b17b71f476fafc24"; //insert here your token generated by Blynk
int ledState = LOW;
bool justNotifyTemperatureAlert = false;

OneWire ds(0);

void setup(void)
{
  // Start Serial
  Serial.begin(115200);

  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, LOW);

  // SSD1306 Init
  display.begin(SSD1306_SWITCHCAPVCC);  // Switch OLED

  // Show image buffer on the display hardware.
  // Since the buffer is intialized with an Adafruit splashscreen
  // internally, this will display the splashscreen.
  display.display();
  delay(2000);
  // Clear the buffer.
  display.clearDisplay();

  ipStatus = "IP: Connecting...";
  switchStatus = "Status: OFF";
  UpdateOled();

  dht.begin();
  
  // Connect to WiFi network
  //WiFi.begin(ssid, password);
  Blynk.begin(auth, ssid, password);
 
  while (Blynk.connected() == false) {
    delay(500);
  }
  
  ipStatus = "IP: Acquiring...";
  UpdateOled();
 
  // Start the server
  server.begin();

  UpdateRSSI(true);

  ipStatus = "IP: " + WiFi.localIP().toString();
   
  UpdateOled();
}

void UpdateRSSI(bool forceRefresh)
{
  if(delaySignalStrengthsCounter > 0 && !forceRefresh)
  {
    delaySignalStrengthsCounter = delaySignalStrengthsCounter -1;
    return;
  }

  float h = dht.readHumidity();
  float t = dht.readTemperature();

  Blynk.virtualWrite(V5, t);
  Blynk.virtualWrite(V6, h);

  CheckIfNotifyTemperatureAlert(t);
  
  delaySignalStrengthsCounter = delaySignalStrengths;
  
  long value = WiFi.RSSI();

  if( value >= -30)
   signalStrengths = "Signal: Amazing";

  if( value < -30 && value >= -67)
   signalStrengths = "Signal: Very Good";

  if( value < -67 && value >= -70)
   signalStrengths = "Signal: Okay";

  if( value < -70 && value >= -80)
   signalStrengths = "Signal: Not Good";

  if( value < -80 && value >= -90)
   signalStrengths = "Signal: Not Good";  
}

void CheckIfNotifyTemperatureAlert(float temp)
{
    
    if(temp < 20 && !justNotifyTemperatureAlert)
    {
      justNotifyTemperatureAlert = true;
      Blynk.notify("Temperatura inferiore ai 20Â°");
    }

    if(temp > 20 && justNotifyTemperatureAlert)
      justNotifyTemperatureAlert = false;
}

void UpdateOled()
{
  display.setTextSize(1);
  display.setTextColor(WHITE);
  
  display.clearDisplay();
   
  display.setCursor(2,2);
  display.println(ipStatus);

  display.setCursor(2,20);
  display.println(signalStrengths);
  
  display.setCursor(2,40);
  display.println(switchStatus);
  
  display.display();
}

// Every time we connect to the cloud...
BLYNK_CONNECTED() {
  // Request the latest state from the server
  Blynk.syncVirtual(V2);
}

// When App button is pushed - switch the state
BLYNK_WRITE(V2) {
  ledState = param.asInt();
  digitalWrite(ledPin, ledState);

  if(ledState == LOW)
    switchStatus = "Status: OFF";
   else
    switchStatus = "Status: ON";
    
  UpdateOled(); 
}

void loop() 
{
  Blynk.run();
  UpdateRSSI(false);
}

float getTemp(){

  byte data[12];
  byte addr[8];
 
  if ( !ds.search(addr)) {
      //no more sensors on chain, reset search
      ds.reset_search();
      return -1000;
  }
 
  if ( OneWire::crc8( addr, 7) != addr[7]) {
      Serial.println("CRC is not valid!");
      return -1000;
  }
 
  if ( addr[0] != 0x10 && addr[0] != 0x28) {
      Serial.print("Device is not recognized");
      return -1000;
  }
 
  ds.reset();
  ds.select(addr);
  ds.write(0x44,1); // start conversion, with parasite power on at the end
 
  byte present = ds.reset();
  ds.select(addr);    
  ds.write(0xBE); // Read Scratchpad
 
  for (int i = 0; i < 9; i++) { // we need 9 bytes
    data[i] = ds.read();
  }
 
  ds.reset_search();
 
  byte MSB = data[1];
  byte LSB = data[0];
 
  float tempRead = ((MSB << 8) | LSB); //using two's compliment
  float TemperatureSum = tempRead / 16;
 
  return TemperatureSum;
 
}





